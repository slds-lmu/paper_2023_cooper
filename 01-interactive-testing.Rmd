---
title: "Interative Experiments"
author: "Lukas"
date: "`r Sys.Date()`"
output: 
  html_document: 
    fig_caption: yes
    self_contained: no
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Load helper functions in R/
source(here::here("02-problems.R"))
source(here::here("R/sim_cr.R"))
source(here::here("R/mt_res_tidy_plot.R"))

knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  out.width = "100%"
)

library(fwelnet)
library(ggplot2)
library(patchwork)
```

Before we set up a proper benchmarking experiment, this serves as a platform for quick-and-dirty interactive experimentation.

## Simulate data


Generate CR endpoint via formula specification and note true effects in separate tbl for plotting purposes (a cleaner solution would be preferable):

```{r sim-data}
set.seed(997)
sim_a_dat <- sim_a(n = 1000)$data
sim_b_dat <- sim_b(n = 1000)$data
sim_c_dat <- sim_c(n = 1000)$data
```

## Run algorithm

Run and plot result individually:

```{r run-plot, eval=FALSE}
set.seed(997)
p1 <- fwelnet_mt_cox(
  sim_c_dat, mt_max_iter = 5,
  z_scale = 1, z_method = "original", t = 100, thresh = 0, a = 0.5, max_iter = 40
) |>
  tidy_mt_res(true_effects) |>
  plot_mt_res(true_effects)

set.seed(997)
p2 <- fwelnet_mt_cox(
  sim_c_dat, mt_max_iter = 5,
  z_scale = 1, z_method = "aligned", t = 100, thresh = 0, a = 0.5, max_iter = 40
) |>
  tidy_mt_res(true_effects) |>
  plot_mt_res(true_effects)

p1 + p2 + plot_annotation(tag_levels = "I")
```

Or maybe something like this, to plot multiple settings side by side?

```{r run-plot-all, fig.height = 8, fig.width = 13}
set.seed(997)
res1 <- fwelnet_mt_cox(sim1, mt_max_iter = 5, z_scale = 1, z_method = "original") 
set.seed(997)
res2 <- fwelnet_mt_cox(sim1, mt_max_iter = 5, z_scale = 20, z_method = "original") 
set.seed(997)
res3 <- fwelnet_mt_cox(sim1, mt_max_iter = 5, z_scale = 60, z_method = "original") 
set.seed(997)
res4 <- fwelnet_mt_cox(sim1, mt_max_iter = 5, z_scale = 100, z_method = "original") 

res_full <- purrr::map_df(list(res1, res2, res3, res4), ~tidy_mt_res(.x, true_effects))

ggplot(res_full, aes(x = iter, y = value, color = xcol, alpha = is_noise)) +
  facet_grid(
    cols = vars(z_method, z_scale), rows = vars(beta),
    labeller = label_context
  ) +
  geom_hline(data = true_effects, aes(yintercept = truth), lty = "dotted") +
  geom_path() +
  scale_x_continuous(breaks = seq(0, 100, 1)) +
  scale_color_brewer(palette = "Dark2") +
  scale_alpha_manual(
    values = c("True effect" = 1, "Noise" = 0.2),
    guide = "none"
  ) +
  labs(
    title = "Multi-Task fwelnet: Multiple results",
    x = "# of Multi-Task Iterations",
    y = "Effect estimate",
    color = "Variable"
  ) +
  theme_minimal() +
  theme(
    panel.spacing.y = unit(1, "cm"),
    legend.position = "top", 
    plot.title.position = "plot"
  )

```

Comparing `z_method` and `z_scale`:

```{r tab-comparison}
# res_full |>
#   dplyr::filter(is_noise != "Noise", z_scale == 1) |>
#   dplyr::select(-is_noise, -xcol, -z_scale, -converged) |> 
#   tidyr::pivot_wider(id_cols = c("x", "iter", "beta"), names_from = "z_method", values_from = "value")

res_full |>
  dplyr::filter(is_noise != "Noise") |>
  dplyr::select(-is_noise, -xcol, -converged) |> 
  tidyr::pivot_wider(id_cols = c("x", "iter", "beta"), names_from = c("z_method", "z_scale"), values_from = "value") |>
  dplyr::select(beta, dplyr::everything()) |>
  dplyr::left_join(true_effects, by = c("beta", "x")) |>
  knitr::kable(
    caption = "Comparison of z_method = {original, aligned} and z_scale = {1, 100}"
  ) |>
  kableExtra::kable_styling() |>
  kableExtra::collapse_rows(columns = c(1, 2))
```

