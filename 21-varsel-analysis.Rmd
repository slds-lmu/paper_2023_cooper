---
title: "Simulation Results: Variable Selection"
author: "Lukas"
date: "`r Sys.time()`"
output: 
  html_document: 
    fig_width: 11
    fig_height: 9
    self_contained: no
    code_folding: hide
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(batchtools)
library(ggplot2)
library(patchwork)
library(dplyr)
library(kableExtra)
library(data.table)

reg_name <- "fwel_sim_varsel"
reg_dir <- here::here("registries", reg_name)
loadRegistry(reg_dir)

theme_set(
  theme_minimal(base_size = 16) +
  theme(
    legend.position = "bottom", 
    panel.spacing = unit(10, "mm"), 
    plot.title.position = "plot"
  )
)
```

```{r get-results, cache = TRUE}
res <-  ijoin(reduceResultsDataTable(), flatten(getJobPars()))
jobs_total <- nrow(getJobTable())
jobs_completed <- 100 * nrow(res)/jobs_total
jobs_errored <- 100 * nrow(findErrors())/jobs_total

res |>
  count(algorithm, problem, t, thresh) |>
  kable(caption = glue::glue("Finished jobs ({jobs_total} total, {jobs_completed}% completed, {jobs_errored}% errored)")) |>
  kable_styling()
```


```{r runtime-plot, fig.height=5, fig.width=7}
getJobTable() |>
  unwrap() |>
  #select(time.running, problem) |>
  mutate(time.running = as.double(time.running, units = "mins")) |>
  group_by(algorithm, problem) |>
  summarize(
    min = min(time.running, na.rm = TRUE),
    mean = mean(time.running, na.rm = TRUE),
    median = median(time.running, na.rm = TRUE),
    max = max(time.running, na.rm = TRUE),
    n = n(),
    n_complete = sum(!is.na(time.running)),
    .groups = "drop"
  ) |>
  mutate(across(where(is.numeric), round, 1)) |>
  kable(caption = "Job runtime (mins)") |>
  kable_styling()
```

```{r prep-unnest-data}
# batchtools::unwrap() doesn't work, so quick tidyr-detour circling back to data.table
res_long <- tidyr::unnest(res, "result") |> 
  as.data.table()

# Make threshold scientific notation for consistency, it's a character then though.
res_long[, thresh := format(thresh, scientific = TRUE)]
res_long[, block := gsub("3", "3.", block)]
res_long[, block := factor(block, levels = sort(unique(block)))]

# Params for methods
params_fwelnet <- c("t", "thresh", "mt_max_iter", "alpha")
params_rfsrc <- c("importance", "cutoff_method", "mtry", "nodesize", "splitrule")
params_coxboost <- c("cmprsk", "stepno", "penalty")

params_sim <- c("n_train", "p", "ce", "lambda1", "lambda2", "lambda_c")
# tbl_sim_params <- res_long |>
#   select(job.id, params_sim) |>
#   tidyr::pivot_longer(cols = -job.id, names_to = "sim_param", values_to = "sim_param_value")
# 
# tbl_fwelnet_params <- res_long |>
#   filter(algorithm == "fwel_mt") |>
#   select(-params_sim, -params_rfsrc, -params_coxboost) |>
#   tidyr::pivot_longer(cols = params_fwelnet, names_to = "algorithm_param", values_to = "algorithm_param_value", values_transform = as.character)
# 
# tbl_rfsrc_params <- res_long |>
#   filter(algorithm == "rfsrc") |>
#   select(-params_sim, -params_fwelnet, -params_coxboost) |>
#   tidyr::pivot_longer(cols = params_rfsrc, names_to = "algorithm_param", values_to = "algorithm_param_value", values_transform = as.character)
# 
# 
# 
# 

# res_long |>
#   tidyr::unite(col = model_params, params_fwelnet, sep = ";", na.rm = TRUE) |>
#   select(model_params)

```

For blocks without true effects, some measures should be NA rather than 0 to not confuse them:  
True positive & false negative are not meaningful in the absence of true effects -> NA -> derived measures are NA as well

```{r prep-cleanup-nonmeaningful-values}
res_long[total_pos == 0, tp := NA]
res_long[total_pos == 0, fn := NA]
```

Calculating derived measures, generating a lot of NAs for blocks without true effects.

```{r prep-calc-stats}
# TPR, FPR, PPV, FDR...
res_long[, tpr := tp/total_pos]
res_long[, fpr := fp/total_neg]
res_long[, ppv := tp/(tp + fp)]
res_long[, npv := tn/(tn + fn)]
res_long[, fdr := 1 - ppv]
res_long[, f1 := (2 * ppv * tpr) / (ppv + tpr)]
res_long[, acc := (tp+tn)/total]
```

### WIP Attempt at subsetting/subplotting

```{r prep-subset}
plot_varselect_boxplot <- function(
    res_long, ..., measure, blocks = c("block1", "block2", "block3.1", "block3.2", "block4", "noise"),
    sim_setting = "equal",
    append_hpc = FALSE
  ) {
  #browser()
  
  tmp <- res_long |> filter(...)
  
  if (sim_setting == "equal") {
    tmp <- tmp |> filter(lambda1 == lambda2)
    label_sub <- "Setting with roughly equal proportions of causes 1 & 2" 
  } else if (sim_setting == "less_2") {
    tmp <- tmp |> filter(lambda1 > lambda2)
    label_sub <- "Setting with cause 2 appearing less frequently than cause 1"
  }
  
  tmp |>
    filter(.data$block %in% .env$blocks) |>
    mutate(
      # model = ifelse(model == "rfsrc", glue::glue("{model} (mtry={mtry})"), model),
      # model = ifelse(model == "coxboost", glue::glue("{model} ({cmprsk})"), model)
    ) |>
    tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
    filter(.data$measure == .env$measure) |>
    # Pre=plot cosmetics
    mutate(
      cause = paste0("Cause ", cause),
      block = stringr::str_replace_all(block, "block", "Block ")
    ) |>
    ggplot(aes(y = reorder(model, value), x = value, color = model, fill = model)) +
    facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
    #coord_flip() +
    geom_boxplot(alpha = 0.5, show.legend = FALSE) +
    scale_x_continuous(labels = scales::label_percent()) +
    scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
    labs(
      title = glue::glue("Variable Selection Performance: {measure}"),
      subtitle = label_sub,
      y = NULL, x = glue::glue("{measure} [%]")
    )
}

plot_varselect_boxplot(
  res_long, measure = "PPV", 
  #model %in% c("fwelnet", "glmnet"),
  blocks = c("block1", "block2", "block3.1", "block3.2")
)

plot_varselect_boxplot(
  res_long, measure = "FPR", 
  blocks = c("block1", "block2", "block3.1", "block3.2", "noise")
)
```



## Covariates & true effects

```{r, include = FALSE}
tmp <- sim_surv_binder(n_train = 400, p = 5000)
truth <- tmp$covar_true_effect |> sapply(length)
total <- tmp$covar_blocks |> sapply(length)
```

Simulated data dimensions: n = 400, p = 5000

- **block 1**: 
    - correlation of 0.50 for j ≤ 0.05p
    - same effect (0.5) on both causes
    - true effects / variables per block: `r truth[["block1"]]` / `r total[["block1"]]`
- **block 2**: 
    - correlation of 0.35 for 0.05p < j ≤ 0.1p
    - Effects:
        - 0.5 on cause 1
        - -0.5 on cause 2
    - true effects / variables per block: `r truth[["block2"]]` / `r total[["block2"]]`
- **block 3**: 
    - correlation of 0.05 for 0.1p < j ≤ 0.2p
    - **block 3.1**, effect on cause 1 only: `r truth[["block31"]]` / `r total[["block31"]]`
    - **block 3.2**, effect on cause 2 only: `r truth[["block32"]]` / `r total[["block32"]]`
- **block 4**: 
    - correlation of 0.32 for 0.2p < j ≤ 0.3p
    - no effect on either cause
    - true effects / variables per block: `r truth[["block4"]]` / `r total[["block4"]]`
  
## Confusion Matrix stats
 
```{r confmat-measures-boxplot, fig.height=12}
res_long |>
  mutate(
    cause = paste0("Cause ", cause),
    model = ifelse(model == "rfsrc", glue::glue("{model} (mtry={mtry})"), model),
    model = ifelse(model == "coxboost", glue::glue("{model} ({cmprsk})"), model)
  ) |>
  tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
  ggplot(aes(x = block, y = value, color = model, fill = model)) +
  facet_grid(rows = vars(measure), cols = vars(cause), scales = "free") +
  #coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "Classification by model and covariate block",
    x = "Block", y = "Rate [%]"
  )
```

### As a table

#### Median and quartiles

```{r confmat-measures-table}
res_long |>
  group_by(block, cause, model) |>
  summarise(across(tpr:acc, ~{
    # m <- round(mean(.x, na.rm = TRUE) * 100, 2)
    m <- round(median(.x, na.rm = TRUE) * 100, 2)
    qu <- round(quantile(.x * 100, probs = c(0.25, 0.75), na.rm = TRUE), 2)
    ifelse(
      is.finite(m),
      glue::glue("{m} <br\\> [{qu[[1]]}, {qu[[2]]}]"),
      "-"
    )
  }), 
  .groups = "drop"
  ) |>
  kable(
    escape = FALSE,
    caption = "Median [p25, p75], measures multiplied by 100"
  ) |>
  kable_styling(bootstrap_options = c("hover")) |>
  collapse_rows(1:2)
```

#### Mean and quartiles

```{r confmat-measures-table-mean}
res_long |>
  group_by(block, cause, model) |>
  summarise(across(tpr:acc, ~{
    m <- round(mean(.x, na.rm = TRUE) * 100, 2)
    qu <- round(quantile(.x * 100, probs = c(0.25, 0.75), na.rm = TRUE), 2)
    ifelse(
      is.finite(m),
      glue::glue("{m} <br\\> [{qu[[1]]}, {qu[[2]]}]"),
      "-"
    )
  }), .groups = "drop") |>
  kable(
    escape = FALSE,
    caption = "Mean [p25, p75], measures multiplied by 100"
  ) |>
  kable_styling(bootstrap_options = c("hover")) |>
  collapse_rows(1:2)
```

#### Raw confusion matrix stats

For completion's sake, the average confusion matrix stats (true positive, true negative, false positive...)

```{r confmat-measures-table-median}
res_long |>
  group_by(block, cause, model) |>
  summarise(across(c(tp, tn, fp, fn), ~{
    m <- round(mean(.x, na.rm = TRUE), 2)
    qu <- round(quantile(.x, probs = c(0.25, 0.75), na.rm = TRUE), 2)
    ifelse(
      is.finite(m),
      glue::glue("{m} [{qu[[1]]}, {qu[[2]]}]"),
      "-"
    )  
  }), .groups = "drop") |>
  kable(
    caption = "Mean [p25, p75]"
  ) |>
  kable_styling(bootstrap_options = c("hover")) |>
  collapse_rows(1:2)
```



### Positive: Detection of true effects

TPR, PPV, F1?

Note on F1: Depends on ratio of positive/negative labels in true data, so comparison across different blocks with different numbers of true effects is not ideal.

```{r blockwise-pos-measures-boxplot, fig.height=12}
res_long |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause)
  ) |>
  tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
  filter(measure %in% c("ACC","TPR", "PPV", "F1")) |>
  filter(!is.na(value)) |>
  ggplot(aes(x = model, y = value, color = model, fill = model)) +
  facet_grid(rows = vars(cause, measure), cols = vars(block), scales = "free") +
  #coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "Classification metrics by model and covariate block",
    x = "Model", y = "Rate [%]", color = NULL, fill = NULL
  )
```

Subset to only PPV with more model differentiation

```{r blockwise-ppv-boxplot}
res_long |>
  filter(lambda2 == lambda1) |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause),
    model = ifelse(model == "rfsrc", glue::glue("{model} (mtry={mtry})"), model),
    model = ifelse(model == "coxboost", glue::glue("{model} ({cmprsk})"), model)
  ) |>
  tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
  filter(measure %in% c("PPV")) |>
  filter(!is.na(value)) |>
  ggplot(aes(x = reorder(model, value), y = value, color = model, fill = model)) +
  facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
  coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "Classification metrics by model and covariate block",
    subtitle = "Simulation setting with approx. equal proportions of cause 1 and 2",
    x = "Model", y = "PPV [%]", color = NULL, fill = NULL
  )

res_long |>
  filter(lambda2 < lambda1) |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause),
    model = ifelse(model == "rfsrc", glue::glue("{model} (mtry={mtry})"), model),
    model = ifelse(model == "coxboost", glue::glue("{model} ({cmprsk})"), model)
  ) |>
  tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
  filter(measure %in% c("PPV")) |>
  filter(!is.na(value)) |>
  ggplot(aes(x = reorder(model, value), y = value, color = model, fill = model)) +
  facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
  coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "Classification metrics by model and covariate block",
    subtitle = "Simulation setting with cause 2 having smaller event counts",
    x = "Model", y = "PPV [%]", color = NULL, fill = NULL
  )
```

#### CoxBoost only

```{r blockwise-ppv-coxboost}
res_long |>
  filter(lambda2 == lambda1, model == "coxboost") |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause),
    model = ifelse(model == "coxboost", glue::glue("{model} ({cmprsk}, penalty={penalty}, stepno={stepno})"), model)
  ) |>
  tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
  filter(measure %in% c("PPV")) |>
  filter(!is.na(value)) |>
  ggplot(aes(x = reorder(model, value), y = value)) +
  facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
  coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  #scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "CoxBoost: Classification metrics by model and covariate block",
    subtitle = "Simulation setting with approx. equal proportions of cause 1 and 2",
    x = "Model", y = "PPV [%]", color = NULL, fill = NULL
  )
```

#### RFSRC only

```{r blockwise-ppv-rfsrc}
res_long |>
  filter(lambda2 == lambda1, model == "rfsrc") |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause),
    model = ifelse(model == "rfsrc", glue::glue("{model} (mtry={mtry}, {nodesize})"), model)
  ) |>
  tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
  filter(measure %in% c("PPV")) |>
  filter(!is.na(value)) |>
  ggplot(aes(x = reorder(model, value), y = value)) +
  facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
  coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  #scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "RFSRC: Classification metrics by model and covariate block",
    subtitle = "Simulation setting with approx. equal proportions of cause 1 and 2",
    x = "Model", y = "PPV [%]", color = NULL, fill = NULL
  )
```

### Negative: Removal of noise variables

Focusing on FPR.  
Especially relevant: Block4 without any true effects, and blocks 3.1 for cause 2 / block 3.2 for cause 1.

```{r blockwise-fpr-boxplot}
res_long |>
  filter(lambda1 == lambda2) |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause),
    model = ifelse(model == "rfsrc", glue::glue("{model} (mtry={mtry})"), model),
    model = ifelse(model == "coxboost", glue::glue("{model} ({cmprsk})"), model)
  ) |>
  ggplot(aes(x = model, y = fpr, color = model, fill = model)) +
  facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
  coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format(), limits = c(0, .12)) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "False Positive Rate by model and covariate block",
    subtitle = "No true effects on cause 1 in block 3.2 (and vice versa)\nNo true effects in block 4 at all",
    x = "Model", y = "False Positive Rate [%]", color = NULL, fill = NULL
  )

res_long |>
  filter(block != "block1", block != "block2", lambda1 == lambda2) |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause),
    model = ifelse(model == "rfsrc", glue::glue("{model} (mtry={mtry})"), model),
    model = ifelse(model == "coxboost", glue::glue("{model} ({cmprsk})"), model)
  ) |>
  ggplot(aes(x = reorder(model, -fpr), y = fpr, color = model, fill = model)) +
  facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
  coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "False Positive Rate by model and covariate block",
    subtitle = "No true effects on cause 1 in block 3.2 (and vice versa)\nNo true effects in block 4 at all",
    x = "Model", y = "False Positive Rate [%]", color = NULL, fill = NULL
  )
```


### ROC-Like Bidimensional Scatter

Hard to make out anything useful except that fwelnet seems to work fine and block3.2/cause 2 is harder than 3.1/cause 1 :/

```{r roc, eval = FALSE}
res_long |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause)
  ) |>
  filter(!is.na(tpr)) |>
  ggplot(aes(x = fpr, y = tpr, color = model, fill = model)) +
  facet_grid(rows = vars(block), cols = vars(cause), scales = "free") +
  geom_point(position = position_jitter(width = 0.01, height = 0.01), alpha = .5, size = 3) +
  geom_hline(yintercept = 1:4 * 0.25, lty = "dashed", color = "darkgray") +
  geom_abline(slope = 1, intercept = 0, lty = "dashed", color = "black") +
  scale_x_continuous(labels = scales::percent_format(), limits = c(0, 1)) +
  scale_y_continuous(labels = scales::percent_format(), breaks = 0:4 * 0.25) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill")) +
  labs(
    title = "Classification metrics by model and covariate block",
    subtitle = "Jitter +/- 0.01 applied on both axes for visibility",
    x = "False Positive Rate", y = "True Positive Rate", color = NULL, fill = NULL
  )
```


## Selected Plots for Paper


```{r, include=FALSE, eval=FALSE}
# Finding generally best coxboost first
cb_jobs <- res_long |>
  filter(lambda2 == lambda1, model == "coxboost") |>
  select(cause, block, cmprsk, stepno, penalty, tpr:acc)

cb_jobs |>
  rowwise() |>
  mutate(hpc = paste0(c(as.character(cmprsk), penalty, stepno), collapse = "-")) |>
  group_by(hpc) |>
  summarize(median_ppv = median(ppv, na.rm = TRUE)) |>
  arrange(desc(median_ppv))

cb_jobs |>
  rowwise() |>
  mutate(hpc = paste0(c(as.character(cmprsk), penalty, stepno), collapse = "-")) |>
  group_by(hpc) |>
  summarize(median_fpr = median(fpr, na.rm = TRUE)) |>
  arrange(median_fpr)
```


```{r selected-ppv-equallambda}
p_ppv <- res_long |>
  filter(lambda2 == lambda1) |>
  filter(model != "coxboost" | (penalty == 3000 & stepno == 100 & cmprsk == "csh")) |>
  filter(model != "rfsrc" | (mtry == 500)) |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause)
  ) |>
  tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
  filter(measure %in% c("PPV")) |>
  filter(!is.na(value)) |>
  ggplot(aes(x = reorder(model, value), y = value, color = model, fill = model)) +
  facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
  coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill"), guide = "none") +
  labs(
    title = "Detection of true effects: PPV",
    subtitle = "Simulation setting with approx. equal proportions of cause 1 and 2",
    x = NULL, y = "PPV [%]", color = NULL, fill = NULL
  )

ggsave(plot = p_ppv, filename = "selected-ppv-equallambda.pdf", path = "selected-plots", width = 16, height = 7)
```

```{r selected-fpr-equallambda}
p_fpr <- res_long |>
  filter(lambda2 == lambda1) |>
  filter(model != "coxboost" | (penalty == 3000 & stepno == 100 & cmprsk == "csh")) |>
  filter(model != "rfsrc" | (mtry == 500)) |>
  mutate(
    block = stringr::str_replace_all(block, "31", "3.1"),
    block = stringr::str_replace_all(block, "32", "3.2"),
    cause = paste0("Cause ", cause)
  ) |>
  tidyr::pivot_longer(cols = tpr:acc, names_to = "measure", values_to = "value", names_transform = toupper) |>
  filter(measure %in% c("FPR")) |>
  filter(!is.na(value)) |>
  ggplot(aes(x = reorder(model, value), y = value, color = model, fill = model)) +
  facet_grid(rows = vars(cause), cols = vars(block), scales = "free") +
  coord_flip() +
  geom_boxplot(alpha = 0.5) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_color_brewer(palette = "Dark2", aesthetics = c("color", "fill"), guide = "none") +
  labs(
    title = "Susceptibility to noise: FPR",
    subtitle = "Simulation setting with approx. equal proportions of cause 1 and 2",
    x = NULL, y = "FPR [%]", color = NULL, fill = NULL
  )

ggsave(plot = p_fpr, filename = "selected-fpr-equallambda.pdf", path = "selected-plots", width = 16, height = 7)

```
