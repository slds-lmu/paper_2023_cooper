---
title: "Simulation Results"
author: "Lukas"
date: "`r Sys.time()`"
output: 
  html_document: 
    fig_width: 11
    fig_height: 9
    self_contained: no
    code_folding: hide
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source(here::here("1-proof-of-concept/mt_res_tidy_plot.R"))
source(here::here("1-proof-of-concept/sim01-problems.R"))

library(batchtools)
library(ggplot2)
library(patchwork)
library(dplyr)
library(kableExtra)

reg_name <- "fwel_simulations"
reg_dir <- here::here("registries", reg_name)
loadRegistry(reg_dir)
```

```{r get-results,eval=!file.exists(here::here("1-proof-of-concept", "res.rds"))}
res <-  ijoin(reduceResultsDataTable(), flatten(getJobPars()))
saveRDS(res, file = here::here("1-proof-of-concept", "res.rds"))

nrow(res)/nrow(getJobTable())
nrow(findErrors())/nrow(getJobTable())

res |>
  count(problem, z_scale, z_method, theta, t, thresh)
```

```{r eval=file.exists(here::here("1-proof-of-concept", "res.rds"))}
res_long <- readRDS(here::here("1-proof-of-concept", "res.rds"))
```


```{r runtime-plot}
getJobTable() |>
  select(time.running, problem) |>
  mutate(time.running = as.double(time.running, units = "secs")) |>
  ggplot(aes(x = problem, y = time.running)) +
  geom_boxplot() +
  labs(
    title = "Job Runtime",
    x = "Setting", y = "Runtime (s)"
  ) +
  theme_minimal()
```

```{r tidy-results, cache = TRUE, dependson="get-results", eval=!file.exists(here::here("1-proof-of-concept", "res_long.rds"))}
res_long <- tidy_mt_res_bt(res, true_effects)
saveRDS(res_long, file = here::here("1-proof-of-concept", "res_long.rds"))
```

```{r eval=file.exists(here::here("1-proof-of-concept", "res_long.rds"))}
res_long <- readRDS(here::here("1-proof-of-concept", "res_long.rds"))
```


## Estimates over mt-iterations

```{r plot-estimates-per-iter}
lineplot_bt_res(res_long, true_effects, "sim_a", exclude_noise = F, t %in% c(1, 100), thresh %in% c(0, 1e-3))
lineplot_bt_res(res_long, true_effects, "sim_b", exclude_noise = F, t %in% c(1, 100), thresh %in% c(0, 1e-3))
lineplot_bt_res(res_long, true_effects, "sim_c", exclude_noise = F, t %in% c(1, 100), thresh %in% c(0, 1e-3))
lineplot_bt_res(res_long, true_effects, "sim_d", exclude_noise = F, t %in% c(1, 100), thresh %in% c(0, 1e-3))
```


## Boxplot for `true-estimated`

```{r}
plot_errors_boxplot <- function(res_long, true_effects, problem, 
                                z_method = "original", z_scale = 1, iter_max = 2, t = 1, thresh = 1e-3) {
  # shoddy vectorization with auto-patchworking
  if (length(problem) > 1) {
    p_list <- purrr::map(problem, 
                         ~plot_errors_boxplot(
                           res_long = res_long,
                           true_effects = true_effects, problem = .x, z_method = z_method, 
                           z_scale = z_scale, iter_max = iter_max, thresh = thresh, t = t
                         )
    )
    
    p <- Reduce(`+`, p_list) + 
      patchwork::plot_layout(ncol = 2, guides = "collect") +
      patchwork::plot_annotation(
        # title = "Test title pls ignore", 
        caption = glue::glue("z_method: {z_method}, iter_max: {iter_max}")
      ) & 
      theme(legend.position = "bottom", plot.caption = element_text(size = 12))
    
    return(p)
  }
  
  res_long |>
    filter(
      # iter == 0 is the glmnet solution, compare that with a given iteration of fwelnet
      iter %in% c(0, !!iter_max), 
      xcol != "Noise", z_method == !!z_method, z_scale %in% !!z_scale, t %in% !!t, thresh %in% !!thresh) |>
    select(-is_noise, -converged, -xcol) |>
    # join true betas from design tbl for nonzero-effects
    left_join(true_effects, by = c("problem", "beta", "x")) |>
    mutate(
      iter = if_else(iter == 0, "glmnet", "fwelnet_mt"),
      # truth doesn't contain true 0s, manually hacking them in here
      truth = ifelse(is.na(truth), 0, truth),
      error = truth - value,
      # Just for optics
      beta = stringr::str_replace_all(beta, "beta", "Cause ")
      # z_scale = paste("Z-scalar:", z_scale),
      # theta = paste("theta:", theta)
    ) |>
    dplyr::filter(.data$problem == !!problem) |> 
    ggplot(aes(x = x, y = error, fill = iter, color = iter)) +
    facet_grid(rows = vars(beta), cols = vars(z_scale, theta, t, thresh), labeller = label_context) +
    geom_hline(yintercept = 0, lty = "longdash", size = 1) +
    #geom_jitter(alpha = 0.1, position = position_dodge2(width = .5, preserve = "single")) +
    geom_boxplot(alpha = 0.2) +
    scale_color_brewer(
      palette = "Dark2", aesthetics = c("color", "fill"), 
      labels = c(fwelnet_mt = "Multi-Task fwelnet", glmnet = "Cause-Specific glmnet"),
      name = NULL
    ) +
    labs(
      title = NULL,
      subtitle = sim_labels[[problem]],
      x = NULL, y = "Error (true - estimated)"
    ) +
    theme_minimal(base_size = 16) +
    theme(
      panel.spacing = ggplot2::unit(1, "cm"),
      legend.position = "bottom",
      plot.title.position = "plot"
    )
}
```

```{r}
# This version does not show z_scale/z_method
plot_errors_boxplot_reduced <- function(res_long, true_effects, problem, 
                                iter_max = 2, t = 1, thresh = 1e-3) {
  # shoddy vectorization with auto-patchworking
  if (length(problem) > 1) {
    p_list <- purrr::map(problem, 
                         ~plot_errors_boxplot(
                           res_long = res_long,
                           true_effects = true_effects, problem = .x, 
                           iter_max = iter_max, thresh = thresh, t = t
                         )
    )
    
    p <- Reduce(`+`, p_list) + 
      patchwork::plot_layout(ncol = 2, guides = "collect") +
      patchwork::plot_annotation(
        # title = "Test title pls ignore", 
        caption = glue::glue("iter_max: {iter_max}")
      ) & 
      theme(legend.position = "bottom", plot.caption = element_text(size = 12))
    
    return(p)
  }
  
  res_long |>
    filter(
      # iter == 0 is the glmnet solution, compare that with a given iteration of fwelnet
      iter %in% c(0, !!iter_max), 
      xcol != "Noise", z_method == "original", z_scale == 1, t %in% !!t, thresh %in% !!thresh, theta == "original") |>
    select(-is_noise, -converged, -xcol) |>
    # join true betas from design tbl for nonzero-effects
    left_join(true_effects, by = c("problem", "beta", "x")) |>
    mutate(
      iter = if_else(iter == 0, "glmnet", "fwelnet_mt"),
      # truth doesn't contain true 0s, manually hacking them in here
      truth = ifelse(is.na(truth), 0, truth),
      error = truth - value,
      # Just for optics
      beta = stringr::str_replace_all(beta, "beta", "Cause ")
      # z_scale = paste("Z-scalar:", z_scale),
      # theta = paste("theta:", theta)
    ) |>
    dplyr::filter(.data$problem == !!problem) |> 
    ggplot(aes(x = x, y = error, fill = iter, color = iter)) +
    facet_grid(rows = vars(beta), cols = vars(t, thresh), labeller = label_context) +
    geom_hline(yintercept = 0, lty = "longdash", size = 1) +
    #geom_jitter(alpha = 0.1, position = position_dodge2(width = .5, preserve = "single")) +
    geom_boxplot(alpha = 0.2) +
    scale_color_brewer(
      palette = "Dark2", aesthetics = c("color", "fill"), 
      labels = c(fwelnet_mt = "Multi-Task fwelnet", glmnet = "Cause-Specific glmnet"),
      name = NULL
    ) +
    labs(
      title = NULL,
      subtitle = sim_labels[[problem]],
      x = NULL, y = "Error (true - estimated)"
    ) +
    theme_minimal(base_size = 16) +
    theme(
      panel.spacing = ggplot2::unit(1, "cm"),
      legend.position = "bottom",
      plot.title.position = "plot"
    )
}
```


### Original `z_method`

```{r error-bp-A, fig.width=12.5}
plot_errors_boxplot(res_long, true_effects, "sim_a", z_scale = c(1, 100), iter_max = 5, t = c(1, 50, 100), thresh = c(0, 1e-3))
```

```{r error-bp-B, fig.width=12.5}
plot_errors_boxplot(res_long, true_effects, "sim_b", z_scale = c(1, 100), iter_max = 5, t = c(1, 50, 100), thresh = c(0, 1e-3))
```

```{r error-bp-C, fig.width=12.5}
plot_errors_boxplot(res_long, true_effects, "sim_c", z_scale = c(1, 100), iter_max = 5, t = c(1, 50, 100), thresh = c(0, 1e-3))
```

```{r error-bp-D, fig.width=12.5}
plot_errors_boxplot(res_long, true_effects, "sim_d", z_scale = c(1, 100), iter_max = 5, t = c(1, 50, 100), thresh = c(0, 1e-3))
```

```{r error-bp-all, fig.width=18, fig.height=16}
plot_errors_boxplot(
  res_long, true_effects, names(sim_labels), z_scale = c(1, 100), iter_max = 5, t = c(1, 100), thresh = c(0, 1e-3)
)
```

### Tabular maybe?

```{r median-q-table}
res_long |>
  filter(
    iter %in% c(0, 5), 
    xcol != "Noise", z_method == "original", theta == "original") |>
  select(-is_noise, -converged, -xcol, -z_method, -theta) |>
  # join true betas from design tbl for nonzero-effects
  left_join(true_effects, by = c("problem", "beta", "x")) |>
  mutate(
    iter = if_else(iter == 0, "glmnet", "fwelnet_mt"),
    # truth doesn't contain true 0s, manually hacking them in here
    truth = ifelse(is.na(truth), 0, truth),
    error = truth - value,
    # Just for optics
    #beta = stringr::str_replace_all(beta, "beta", "Cause "),
    thresh = case_when(
      thresh == 0 ~ "0",
      thresh == 1e-3 ~ "10^-3",
      thresh == 1e-7 ~ "10^-7"
    )
  ) |>
  group_by(problem, x, beta, iter, z_scale, t, thresh) |>
  summarize(
    # mean_error = round(mean(error), 3),
    # sd_error = round(sd(error), 3),
    median_error = round(median(error), 3),
    #q1_error = round(quantile(error, prob = 0.25), 2),
    #q3_error = round(quantile(error, prob = 0.75), 2),
    # mean_sd = glue::glue("{mean_error} ({sd_error})"),
    # median_q = glue::glue("{median_error} ({q1_error}, {q3_error})"),
    .groups = "drop"
  ) |>
  #arrange(problem, beta, iter, mean_sd) |>
  # ungroup() |>
  #select(-ends_with("error")) |>
  mutate(
    median_error = cell_spec(median_error, color = spec_color(median_error, direction = 1, end = 0.8, option = "B"))
  ) |>
  tidyr::pivot_wider(names_from = c("iter", "beta"), values_from = c("median_error")) |>
  select(-problem) |>
  kable(
    escape = FALSE, 
    caption = "Median error (true-estimated) for effect/non-noise variable per cause and setting",
    col.names = c("x", "z-scale", "t", "threshold", "fwelnet", "glmnet", "fwelnet", "glmnet")
  ) |>
  kable_styling(bootstrap_options = c("striped", "hover")) |>
  add_header_above(c(" " = 4, "Cause 1" = 2, "Cause 2" = 2)) |>
  pack_rows(sim_labels[["sim_a"]], 1,  13) |>
  pack_rows(sim_labels[["sim_b"]], 14, 39) |>
  pack_rows(sim_labels[["sim_c"]], 40, 52) |>
  pack_rows(sim_labels[["sim_d"]], 53, 91) |>
  collapse_rows(columns = c(1))
```


### RMSE ± SD Maybe?

```{r rmse-errorbars-fun}
plot_rmse_errorbars <- function(res_long, true_effects, problem, z_method = "original", z_scale = 1, iter_max = 2) {
    # shoddy vectorization with auto-patchworking
  if (length(problem) > 1) {
    p_list <- purrr::map(
      problem, ~plot_rmse_errorbars(
        res_long = res_long,
        true_effects = true_effects, problem = .x, z_method = z_method, 
        z_scale = z_scale, iter_max = iter_max        
        )
      )
    
    p <- Reduce(`+`, p_list) + 
      patchwork::plot_layout(ncol = 2, guides = "collect") +
      patchwork::plot_annotation(
        # title = "Test title pls ignore", 
        caption = glue::glue("z_method: {z_method}, iter_max: {iter_max}")
      ) & 
      theme(legend.position = "bottom", plot.caption = element_text(size = 12))
    
    return(p)
  }
  
  res_long |>
    filter(
      # iter == 0 is the glmnet solution, compare that with a given iteration of fwelnet
      iter %in% c(0, !!iter_max), 
      xcol != "Noise", problem == !!problem, z_method == !!z_method, z_scale %in% !!z_scale) |>
    select(-is_noise, -converged, -xcol) |>
    # join true betas from design tbl for nonzero-effects
    left_join(true_effects, by = c("problem", "beta", "x")) |>
    mutate(
      iter = if_else(iter == 0, "glmnet", "fwelnet_mt"),
      # truth doesn't contain true 0s, manually hacking them in here
      truth = ifelse(is.na(truth), 0, truth),
      error = (truth - value),
      # Just for optics
      beta = stringr::str_replace_all(beta, "beta", "Cause "),
      z_scale = paste("Z-scalar:", z_scale),
      theta = paste("theta:", theta)
    ) |>
    group_by(x, iter, beta, z_scale, z_method, problem, theta) |>
    summarize(
      rmse = sqrt(mean(error^2)),
      rmse_sd = sd(error),
      .groups = "drop"
    ) |>
    ggplot(aes(x = x, y = rmse, color = iter, fill = iter)) +
    facet_grid(rows = vars(beta), cols = vars(z_scale, theta)) +
    geom_errorbar(aes(ymin = rmse - rmse_sd, ymax = rmse + rmse_sd), size = 2, position = "dodge2", width = .5) +
    scale_color_brewer(
      palette = "Dark2", aesthetics = c("color", "fill"),
      labels = c(fwelnet_mt = "Multi-Task fwelnet", glmnet = "Cause-Specific glmnet"),
      name = NULL
    ) +
    labs(
      title = NULL,
      subtitle = sim_labels[[problem]],
      x = NULL, y = "RMSE ± SD"
    ) +
    theme_minimal(base_size = 16) +
    theme(
      panel.spacing = ggplot2::unit(1, "cm"),
      legend.position = "bottom",
      plot.title.position = "plot"
    )
}
```

```{r rmse-errorbars-all, fig.width=18, fig.height=16}
plot_rmse_errorbars(res_long, true_effects, names(sim_labels))
```


## What is theta even

Needs adjusting after introducing theta as a simulation param

```{r plot-theta-lambda, eval = FALSE}
res_long |>
  filter(iter == 2, xcol != "Noise", problem == "sim_c", z_method == "original", theta == "original") |>
  select(-is_noise, -converged, -xcol, -z_method, -iter, -theta) |>
  tidyr::pivot_wider(names_from = "beta", values_from = "value") |>
  rename(beta_c1 = beta1, beta_c2 = beta2) |>
  tidyr::pivot_longer(
    cols = matches("(c1$)|(c2$)"), 
    names_to = c("param", "cause"), names_sep = "_", 
    values_to = "val"
  ) |>
  mutate(cause = stringr::str_replace_all(cause, "c", "Cause ")) |>
  filter(param != "beta") |>
  ggplot(aes(x = param, y = val, color = cause, fill = cause)) +
  facet_grid(cols = vars(z_scale), labeller = label_both) +
  geom_boxplot(alpha = .75) +
  scale_y_log10() +
  scale_color_manual(
    values = RColorBrewer::brewer.pal(4, "Dark2")[3:4],
    aesthetics = c("color", "fill")
  ) +
  labs(
    title = sim_labels[["sim_c"]],
    subtitle = "Parameter values after final fwelnet fit",
    color = NULL, fill = NULL,
    x = NULL, y = "Value"
  ) +
  theme_minimal(base_size = 16) +
  theme(legend.position = "top")

res_long |>
  filter(iter == 2, xcol != "Noise", problem == "sim_c", z_method == "original") |>
  select(-is_noise, -converged, -xcol, -z_method, -iter) |>
  tidyr::pivot_wider(names_from = "beta", values_from = "value") |>
  rename(beta_c1 = beta1, beta_c2 = beta2) |>
  tidyr::pivot_longer(
    cols = matches("(c1$)|(c2$)"), 
    names_to = c("param", "cause"), names_sep = "_", 
    values_to = "val"
  ) |>
  mutate(cause = stringr::str_replace_all(cause, "c", "Cause ")) |>
  filter(param != "beta") |>
  group_by(x, z_scale, problem, param, cause) |>
  summarize(val_m = mean(val))
```


## Selected plots

```{r error-bp-s, fig.width=12.5}
(plot_errors_boxplot_reduced(res_long, true_effects, "sim_a", iter_max = 5, t = 100, thresh = c(0, 1e-7)) +
plot_errors_boxplot_reduced(res_long, true_effects, "sim_b", iter_max = 5, t = 100, thresh = c(0, 1e-7))) /
(plot_errors_boxplot_reduced(res_long, true_effects, "sim_c", iter_max = 5, t = 100, thresh = c(0, 1e-7)) +
plot_errors_boxplot_reduced(res_long, true_effects, "sim_d", iter_max = 5, t = 100, thresh = c(0, 1e-7)))
```

```{r}
p_poc <- res_long |>
  filter(
    # iter == 0 is the glmnet solution, compare that with a given iteration of fwelnet
    iter %in% c(0, 5), 
    xcol != "Noise", z_method == "original", z_scale == 1, t %in% c(100), thresh %in% c(1e-7), theta == "original") |>
  select(-is_noise, -converged, -xcol) |>
  # join true betas from design tbl for nonzero-effects
  left_join(true_effects, by = c("problem", "beta", "x")) |>
  mutate(
    iter = if_else(iter == 0, "glmnet", "fwelnet_mt"),
    # truth doesn't contain true 0s, manually hacking them in here
    truth = ifelse(is.na(truth), 0, truth),
    error = truth - value,
    # Just for optics
    beta = stringr::str_replace_all(beta, "beta", "Cause ")
    # z_scale = paste("Z-scalar:", z_scale),
    # theta = paste("theta:", theta)
  ) |>
  dplyr::mutate(
    Setting = dplyr::case_when(
      problem == "sim_a" ~ "A",
      problem == "sim_b" ~ "B",
      problem == "sim_c" ~ "C",
      problem == "sim_d" ~ "D"
    ),
    x = stringr::str_replace(x, "x", "X"),
    iter = factor(iter, levels = c("glmnet", "fwelnet_mt"))
  ) |>
  ggplot(aes(x = x, y = error, fill = iter, color = iter)) +
  facet_grid(rows = vars(beta), cols = vars(Setting), labeller = labeller(beta = label_context, Setting = label_both), scales = "free_x") +
  geom_hline(yintercept = 0, lty = "longdash", size = 1) +
  #geom_jitter(alpha = 0.1, position = position_dodge2(width = .5, preserve = "single")) +
  geom_boxplot(alpha = 0.2) +
  scale_color_brewer(
    palette = "Dark2", aesthetics = c("color", "fill"), 
    breaks = c("glmnet", "fwelnet_mt"),
    labels = c(glmnet = "Coxnet", fwelnet_mt = "CooPeR"),
    name = NULL
  ) +
  labs(
    title = NULL,
    #subtitle = sim_labels[[problem]],
    x = NULL, y = "Error (true - estimated coefficient)"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    panel.spacing = ggplot2::unit(1, "cm"),
    legend.position = "bottom",
    plot.title.position = "plot",
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank()
  )

p_poc

ggsave(plot = p_poc, filename = "poc-boxplot-errors.pdf", path = here::here("selected-plots"), width = 10, height = 6)
ggsave(plot = p_poc, filename = "poc-boxplot-errors.png", path = here::here("selected-plots"), width = 10, height = 6)

```

